### IntelliJ IDEA ###
out/
!**/src/main/**/out/
!**/src/test/**/out/

### Eclipse ###
.apt_generated
.classpath
.factorypath
.projectll
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

### Mac OS ###
.DS_Store

import pandas as pd
import os
import json
import shutil

class FileOperations:
    
    # ... (diğer metodlar: fast_load_and_clean, get_draft_path vb. AYNI KALACAK) ...

    @staticmethod
    def save_file(df, file_path, is_draft=False):
        """
        Dosyayı güvenli bir şekilde kaydeder.
        Atomic Save kullanır: Önce geçici dosyaya yazar, sonra ismini değiştirir.
        """
        target_path = file_path
        
        # Eğer taslak olarak kaydediliyorsa, taslak yolunu al
        if is_draft:
            # get_draft_path fonksiyonunun bu sınıf içinde tanımlı olduğunu varsayıyoruz
            # Eğer statik değilse FileOperations.get_draft_path olarak çağırın
            target_path = FileOperations.get_draft_path(file_path)
        
        # Kaydetmeden önce arayüz için oluşturduğumuz geçici/gizli sütunları temizle
        save_df = df.copy()
        if "_cached_json_data" in save_df.columns:
            save_df = save_df.drop(columns=["_cached_json_data"])

        # --- DÜZELTME BURADA ---
        # Pandas'ın anlaması için geçici dosyanın uzantısı da .xlsx olmalı!
        # Eskisi: temp_path = target_path + ".tmp" (HATALI)
        
        dir_name = os.path.dirname(target_path)
        file_name = os.path.basename(target_path)
        # Geçici dosya adı: ~$temp_dosyaadi.xlsx
        temp_filename = f"~$temp_{file_name}"
        # Eğer uzantısı yoksa ekle
        if not temp_filename.endswith(".xlsx"):
             temp_filename += ".xlsx"
             
        temp_path = os.path.join(dir_name, temp_filename)
        # -----------------------

        try:
            # 1. Geçici dosyaya kaydet (Uzantı .xlsx olduğu için Pandas hata vermez)
            # engine='openpyxl' eklemek işi garantiye alır
            save_df.to_excel(temp_path, index=False, engine='openpyxl')
            
            # 2. Eğer hedef dosya zaten varsa sil (Windows'ta rename için gereklidir)
            if os.path.exists(target_path):
                os.remove(target_path)
            
            # 3. Geçici dosyanın adını asıl dosya yap
            os.rename(temp_path, target_path)
            return True
            
        except Exception as e:
            print(f"Kayıt hatası: {e}")
            # Hata durumunda geçici dosyayı temizlemeye çalış
            if os.path.exists(temp_path):
                try:
                    os.remove(temp_path)
                except:
                    pass
            return False

    # Diğer metodlarınız (get_draft_path, has_draft, delete_draft) burada aynen kalmalı...
    @staticmethod
    def get_draft_path(original_path):
        directory = os.path.dirname(original_path)
        filename = os.path.basename(original_path)
        return os.path.join(directory, f".~{filename}_draft.xlsx")

    @staticmethod
    def has_draft(original_path):
        draft_path = FileOperations.get_draft_path(original_path)
        return os.path.exists(draft_path)

    @staticmethod
    def delete_draft(original_path):
        draft_path = FileOperations.get_draft_path(original_path)
        if os.path.exists(draft_path):
            try:
                os.remove(draft_path)
            except:
                pass

def on_close(self, event):
        """
        Pencere kapatılmadan önce kaydedilmemiş dosyaları kontrol eden fonksiyon.
        """
        unsaved_files = []
        for tab_name, context in self.tab_contexts.items():
            if not context['df'].equals(context['last_saved_df']):
                unsaved_files.append(tab_name)

        if unsaved_files:
            unsaved_files_str = "\n".join(unsaved_files)
            reply = QMessageBox.question(self, "Uyarı",
                                    f"Aşağıdaki dosyalar kaydedilmemiş:\n\n{unsaved_files_str}\n\nKaydet ve kapat?",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel)

            if reply == QMessageBox.StandardButton.Yes:
                for tab_name in unsaved_files:
                    context = self.tab_contexts.get(tab_name)
                    if context:
                        file_path = context['file_path']
                        df = context['df']
                        
                        # --- ESKİ KOD (SİLİNDİ): success = save_excel(df, file_path) ---
                        # --- YENİ KOD: ---
                        success = FileOperations.save_file(df, file_path, is_draft=False)
                        
                        if success:
                            # Başarıyla kaydedildiyse taslağı temizle
                            FileOperations.delete_draft(file_path)
                            
                            # Logları güncelle
                            for log_entry in self.log_lines:
                                if log_entry['filepath'] == file_path:
                                    log_entry['is_saved'] = True

                            self.save_log_lines_to_log_file()
                            context['last_saved_df'] = df.copy()
                        else:
                            QMessageBox.critical(self, "Hata", f"{tab_name} dosyası kaydedilemedi.")
                            event.ignore() # Kapatmayı iptal et
                            return

                event.accept() # Her şey yolunda, kapat
            elif reply == QMessageBox.StandardButton.No:
                event.accept() # Kaydetme dedi, kapat
            elif reply == QMessageBox.StandardButton.Cancel:
                event.ignore() # Vazgeçti, kapatma
            else:
                event.accept()
        else:
            event.accept() # Kaydedilmemiş dosya yok, direkt kapat



def close_tab(self, index):
        """
        Belirtilen sekmeyi kapatan fonksiyon.
        """
        tab_name = self.tab_widget.tabText(index)
        # Sekme isminde yıldız/taslak varsa temizle ki context'i bulabilelim
        real_tab_name = tab_name.split(" *")[0]
        
        # Context'i bulmaya çalış (İsim değişmiş olabilir)
        context = self.tab_contexts.get(real_tab_name)
        if not context:
             # İsimden bulamadıysa values içinden path ile bulmaya çalış
             for ctx in self.tab_contexts.values():
                 # Bu kısım biraz riskli ama genelde çalışır, tab_name ile eşleşme aramalı
                 pass 
             # Eğer context yoksa (zaten kapatılmışsa) direkt sil
             self.tab_widget.removeTab(index)
             return

        if not context['df'].equals(context['last_saved_df']):
            reply = QMessageBox(self)
            reply.setWindowTitle("Değişiklikleri Kaydet")
            reply.setText(f"'{real_tab_name}' dosyasında değişiklikler var. Kaydetmek istiyor musunuz?")
            reply.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel)
            reply_result = reply.exec()

            if reply_result == QMessageBox.StandardButton.Yes:
                file_path = context['file_path']
                df = context['df']
                
                # --- YENİ KOD ---
                success = FileOperations.save_file(df, file_path, is_draft=False)
                
                if success:
                    FileOperations.delete_draft(file_path) # Taslağı sil
                    
                    # Logları güncelle
                    for log_entry in self.log_lines:
                        if log_entry.get('filepath') == file_path:
                            log_entry['is_saved'] = True
                    self.save_log_lines_to_log_file()
                    
                else:
                    QMessageBox.critical(self, "Hata", f"{real_tab_name} dosyası kaydedilemedi.")
                    return # Kapatma işlemini durdur

            elif reply_result == QMessageBox.StandardButton.Cancel:
                return # İptal etti, sekme kapanmasın

        # Sekmeyi kapat ve context'ten sil
        self.tab_widget.removeTab(index)
        if real_tab_name in self.tab_contexts:
            del self.tab_contexts[real_tab_name]
        
        # Eğer sekme kalmadıysa
        if self.tab_widget.count() == 0:
            self.df = pd.DataFrame()
            # update_table_from_df çağrılmamalı çünkü ortada tablo kalmadı
        else:
            # Kalan sekmeye odaklan
            self.switch_tab(self.tab_widget.currentIndex())



from PyQt6.QtWidgets import QWidget, QLabel, QVBoxLayout, QFrame, QGraphicsDropShadowEffect
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QColor, QPalette, QBrush

class LoadingOverlay(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        
        # Arka planın yarı saydam olması için ayarlar
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False) # Tıklamayı engelle
        self.hide() # Başlangıçta gizli

        # Ana Layout (Merkezlemek için)
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Ortadaki Beyaz Kart (Card)
        self.card = QFrame()
        self.card.setStyleSheet("""
            QFrame {
                background-color: white;
                border-radius: 10px;
                border: 1px solid #ddd;
            }
        """)
        self.card.setFixedSize(250, 100)
        
        # Gölge Efekti (Estetik için)
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(15)
        shadow.setColor(QColor(0, 0, 0, 80))
        shadow.setOffset(0, 5)
        self.card.setGraphicsEffect(shadow)

        # Kartın İçeriği
        card_layout = QVBoxLayout(self.card)
        card_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        card_layout.setSpacing(10)

        # "Yükleniyor..." Yazısı
        self.label = QLabel("Yükleniyor...")
        self.label.setStyleSheet("""
            QLabel {
                color: #333;
                font-size: 16px;
                font-weight: bold;
                font-family: 'Segoe UI', sans-serif;
                border: none;
            }
        """)
        
        # Alt Bilgi (Lütfen bekleyin)
        self.sub_label = QLabel("Veriler işleniyor, lütfen bekleyin.")
        self.sub_label.setStyleSheet("""
            QLabel {
                color: #666;
                font-size: 12px;
                font-family: 'Segoe UI', sans-serif;
                border: none;
            }
        """)
        self.sub_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        card_layout.addWidget(self.label, alignment=Qt.AlignmentFlag.AlignCenter)
        card_layout.addWidget(self.sub_label, alignment=Qt.AlignmentFlag.AlignCenter)

        layout.addWidget(self.card)

    def paintEvent(self, event):
        """Arka planı yarı saydam siyah yapmak için boyama işlemi."""
        # Qt'de overlay yaparken stylesheet bazen sorun çıkarır, en temizi budur:
        painter = QPalette()
        painter.setColor(QPalette.ColorRole.Window, QColor(0, 0, 0, 100)) # 100 alpha (yarı saydam)
        self.setAutoFillBackground(True)
        self.setPalette(painter)
        super().paintEvent(event)

    def resizeEvent(self, event):
        """Pencere boyutu değiştiğinde overlay de değişsin."""
        self.resize(self.parent.size())
        super().resizeEvent(event)


def init_ui(self):
        # ... (mevcut kodlarınız) ...
        
        # En sona ekle:
        self.loading_overlay = LoadingOverlay(self)
        
        # Eğer başlangıçta dosya açılıyorsa, pencere görünmeden işlem başlamasın diye
        # küçük bir zamanlayıcı ile açılışı tetikliyoruz.
        if self.file_paths:
            initial_excel_filepath = self.get_file_path("excel_filepath")
            # 10ms sonra load işlemini başlat (Böylece önce pencere çizilir, sonra loading çıkar)
            QTimer.singleShot(10, lambda: self.open_default_file(initial_excel_filepath))



def resizeEvent(self, event):
        # Overlay varsa boyutunu pencereye eşitle
        if hasattr(self, 'loading_overlay'):
            self.loading_overlay.resize(self.size())
        super().resizeEvent(event)


def open_default_file(self, file_path):
        if not file_path: return

        # ... (Draft kontrol kodlarınız aynen kalıyor) ...

        # Yükleme Başlat
        # self.setCursor(Qt.CursorShape.WaitCursor) # İsterseniz bunu kaldırabilirsiniz
        
        # --- YENİ KISIM ---
        self.loading_overlay.label.setText("Veriler Yükleniyor...")
        self.loading_overlay.show() # Ekrana getir
        self.loading_overlay.raise_() # En öne getir
        # ------------------

        self.loader = FileLoaderThread(final_path_to_load)
        self.loader.loaded.connect(lambda df: self.on_file_loaded(df, file_path, final_path_to_load))
        self.loader.error.connect(self.on_load_error)
        self.loader.start()



def on_file_loaded(self, df, original_path, loaded_path):
        # --- YENİ KISIM ---
        self.loading_overlay.hide() # Yükleme ekranını gizle
        # ------------------
        
        self.setCursor(Qt.CursorShape.ArrowCursor)
        # ... (kalan kodlarınız aynen devam) ...

    def on_load_error(self, error_msg):
        # --- YENİ KISIM ---
        self.loading_overlay.hide() # Hata olsa bile ekranı aç
        # ------------------

        self.setCursor(Qt.CursorShape.ArrowCursor)
        QMessageBox.critical(self, "Hata", f"Yükleme hatası:\n{error_msg}")







